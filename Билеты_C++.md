### Теория (Билеты с  определением)

#### №1.1
**Двоичная система исчисления** - это система, в которой существует только 1 и 0.
Используется в цифровом формате, поскольку легко реализуема на аппаратной логике в виде: есть ток - нет тока.
Из этого происходит, что один бит (Минимально возможная единица хранящая информацию для цифровых устройств) - может быть равна или 1, или 0.

Логическое представление: в логических условия - True\False(1\0).

**Перевод в десятичную и обратно**;
С двоичного в десятичную осуществляется так, на примере числа 1011.
```
1 = 2^0 - 1 * 2^0 = 1
1 = 2^1 - 1 * 2^1 = 2
0 = 2^2 - 1 * 2^2 = 0
1 = 2^3 - 1 * 2^3 = 8
1 + 2 + 0 + 8 = 11
```

С десятичной в двоичную осуществляется так, на примере числа 16.
```
16 / 2 = 8 - остатка нет - 0
8 / 2 = 4 - остатка нет - 0
4 / 2 = 2 - остатка нет - 0
2 / 2 = 1 - остатка нет - 0
1 / 2 = 0 - остаток - 1

10000
```

#### №2.1
**Двоично - шестнадцатеричная система.** - Способ сделать бинарный код более компактным. Каждый символ шестнадцатеричной состоит из 4 бинарных символов.

*Перевод* - По этому перевод можно описать как 2 в 4 степени равна 16. Но, если двоичное число, не состоит из 4 цифр, то в конце добавляется 0. 
Пример, есть число 110100011011. Мы делим число на четырехзначные числа и получаем. 

```
Пример на одной группе:
1101 -> D
0001 -> 1
1011 -> B
```    

**Описание** - Шестнадцатеричная система исчисления. Состоит из 16 символов; цифр от 0 до 9 и латинские буквы с A по F. Применяется для передачи данных, так как позволяет передать большое количество двоичных символов компактной форме. Пример, HEX коды - это код, по которому выдается цвет. Код состоит из трех Байтов - 24 бита. Вид кода `#FFFFFF` - это белый.

**Перевод шестнадцатеричного числа в десятичную и назад.**;

На примере 165BD
```
165BD =
(1 * 16^4) = 65536
(6 * 16^3) = 24576
(5 * 16^2) = 1280
(11 * 16^1) = 176
(13 * 16^0) = 13
65536 + 24576 + 1280 + 176 + 13 = 91 581
```

```
91581 / 16 = 5723 - остаток 13(D)
5723 /16 = 357 - остаток 11(B)
357 / 16 = 22 - остаток 5
22 / 16 = 1 - остаток 6
1 / 16 = 0 - остаток 1
```
#### № 2.2 
**Микроконтроллеры. Описание** - Компактное цифровое устройство или микросхема, которое может выполнять программируемые операции. Также называют - *Однокристальный компьютер*, так как они обладают основными для ЭВМ характеристиками.

Используется там где обычный компьютер это излишне - автоматизация мелких процессов в бытовых устройствах, как пример.

Микроконтроллеры, имеют разные архитектуры - как и процессоры для обычных ЭВМ. Также как и обычный ЭВМ имеет периферию и интерфейсы для их подключения  UART. I2C. SPI. CAN. USB. IEEE.

Как было упомянуто, у микроконтроллеров разные архитектуры. Такие как: RISC(AVR, ARM), CISC(x86), Гарвардская и фон Неймана.

*RISC* (Архитектура командного набора/набора команд) - упрощенная архитектура, быстрее за счет коротких команд. Из-за этого не может выполнять сложные команды(несколько в одном). Не имеют доступа к памяти(полноценно, если сравнивать с *CISC*(через операции с памятью `LOAD STORE`. Загрузка и хранение)). 

*CISC* (Архитектура командного набора/набора команд) - полноценная архитектура. Инструкции более сложные, чем у *RISC*. Команды могут быть сложными(составными). Может обращаться к памяти.

*Гарвардская архитектура* (Архитектура памяти) - по сути, это разделение чтения команд и данных(две разные шины)(Доступ к памяти с инструкциями и доступ к памяти данных). Была разработана как альтернатива     
*архитектуры фон Неймана*. 

Отличалась, отсутствием эффекта узкого горлышка бутылки, когда нужно выполнить чтение и произвести операцию.

*Архитектура Неймана* (Архитектура памяти) - линейная архитектура(одна шина). Мы вводим команды они предаются *ЦП*, читаются *УУ* и выполняются *АЛУ*, а при выполнении сохраняются в памяти. После выполнения производится вывод.   

*Архитектура командного набора/набора команд* - вид команд, то как они выполняются, какие есть в принципе.

*Архитектура памяти* - Организация памяти, то как оно взаимодействует с компонентами устройства. 

#### Логические элементы. (N3.1 по 30.1)

*Цифры в названии* - количество входов; сколько одно битных сигналов может принять элемент.

 **НЕ**_(NOT)_ - один вход принимает один сигнал и инвертирует его в противоположный (0 -> 1 или 1 -> 0).

 **2 И**_(AND)_ - два входа, если оба 1 на выходе 1, иначе выдаст 0.

**2 ИЛИ(OR)** - два входа, если на хотя бы на одном единица, то на выходе единица, если оба ноль будет ноль.

**2 Исключающие ИЛИ(XOR)** - два входа, похож на _ИЛИ_, но если на обоих входах 1 выход будет 0 

**2 Исключающие ИЛИ-НЕ(XNOR)** - два входа, если два входа идентичны выдаст 1, иначе выдаст 0.

**2 И-НЕ(NAND)** - два входа, если оба входа 1 выдаст 0, иначе выдаст 1.  

**2 ИЛИ-НЕ** - два входа, ожидает, что хотя бы одни из них будет единицей. Если один из них единица выход 0 - если оба нули, то 1.
### Графическое Обозначение и Таблица истинности.

#### Логические элементы.

**НЕ(NOT)** - Треугольник или квадрат(Прямоугольник), с кружком на выходе.

![](https://electricalschool.info/uploads/posts/2017-08/1503050369_6.gif)

*Таблица истинности для НЕ*:

| X1  | Y   |
| --- | --- |
| 0   | 1   |
| 1   | 0   |

**И(AND)** - Прямоугольник с символом _&_. Либо D-образная фигура, плоская сторона входы.

![](https://electricalschool.info/uploads/posts/2017-08/1503050305_2.gif)

_Таблица Истинности для 2 И_:

| X2  | X1  | Y   |
| --- | --- | --- |
| 0   | 1   | 0   |
| 1   | 1   | 1   |
| 1   | 0   | 0   |
| 0   | 0   | 0   |

**Исключающие ИЛИ(XOR)** - Прямоугольник с символом _=1_. Либо D-образная фигура, но перед плоской стороной изогнута линия.

![](https://electricalschool.info/uploads/posts/2017-08/1503050362_12.gif)

| X2  | X1  | Y   |
| --- | --- | --- |
| 0   | 1   | 1   |
| 1   | 1   | 0   |
| 0   | 0   | 0   |
| 1   | 0   | 1   |

**ИЛИ(OR)** - Прямоугольник с символом _1_. Либо D-образная фигура, но линяя входов выпуклая.

![](https://electricalschool.info/uploads/posts/2017-08/1503050277_4.gif)

| X2  | X1  | Y   |
| --- | --- | --- |
| 1   | 1   | 1   |
| 0   | 1   | 1   |
| 0   | 0   | 0   |
| 1   | 0   | 1   |

**Исключающие ИЛИ-НЕ(XNOR)** - Прямоугольник с символом _=1_ и кружок на выходе. Либо D-образная фигура, но перед плоской стороной изогнута линия и на выходе кружки.

| X2  | X1  | Y   |
| --- | --- | --- |
| 1   | 1   | 1   |
| 0   | 0   | 1   |
| 1   | 0   | 0   |
| 0   | 1   | 0   |

**И-НЕ(NAND)** - Прямоугольник с символом _&_ и кружком на выходе. Либо D-образная фигура с кружном на выходе.

| X2  | X1  | Y   |
| --- | --- | --- |
| 1   | 1   | 0   |
| 0   | 0   | 1   |
| 1   | 0   | 1   |
| 0   | 1   | 1   |

**ИЛИ-НЕ(NOR)** - Прямоугольник с символом _1_ и кружком на выходе. Либо полусфера где выход на плоской, а входы на выпуклой.

| X2  | X1  | Y   |
| --- | --- | --- |
| 1   | 0   | 0   |
| 0   | 0   | 1   |
| 1   | 1   | 0   |
| 0   | 1   | 0   |



#### Общая таблица логических элементов.

![](https://electricalschool.info/uploads/posts/2022-07/1657614877_1.jpg)

### Триггеры билеты №8-12, 25-30.

#### RS -Триггер (Reset-Set)

**Схема**
![](https://digteh.ru/CVT/trigg/02.gif)

По сути, этот триггер имеет два входа *S* и *R*. По *S* задается значение - если по нему один он его сохраняет. А *R* же, сбрасывает значение, если по нему идет единица. 

*S(Set)* - Устанавливает 1.
*R(Resets)* - сбрасывает до 0.

*Q(t)* - выход триггера *Qn(t)* - выход с инверсией. 

##### Таблица истинности.

| *S* | *R* | *Q(t)*         | *Qn(t)*        | *Состояние*                       |
| --- | --- | -------------- | -------------- | --------------------------------- |
| 0   | 1   | 0              | 1              | Состоянии (0) сброса.             |
| 1   | 0   | 1              | 0              | Состоянии (1) установка (задает). |
| 1   | 1   | Неопределённое | Неопределённое | Запрещенное состояние.            |
| 0   | 0   | Q(t-1)         | Qn(t-1)        | Хранения.                         |


#### JK - Триггер.

Версия *RS - триггера* без запрещенного состояния.
Считается универсальным - позволяет реализовать на себе логику любого триггера

*J(Set)* - устанавливает единицу.
*K(Reset)* - сбрасывает.
*C(Clock)* - тактовый сигнал.
*Q(t)* - выход триггера *Qn(t)* - выход с инверсией. 

*Схема*
![](https://digteh.ru/digital/JKtrigg/06.gif)


| *J* | *K* | *Q(t-1)* | *Q(t)* | *Qn(t)* | *Состояние*     |
| --- | --- | -------- | ------ | ------- | --------------- |
| 0   | 0   | Q(t-1)   | Q(t-1) | Q(t-1)  | Хранение        |
| 0   | 1   | 1        | 0      | 1       | Сброс           |
| 1   | 0   | 0        | 1      | 0       | Установка       |
| 1   | 1   | 0        | 1      | 0       | Инверсия 0-> 1  |
| 1   | 1   | 1        | 0      | 1       | Инверсия 1 -> 0 |

#### D - триггер.

Сигнал входит в *C*, а *D* просто копирует сигнал.
*D* = *C*

*D(Delay)* - вход с импульсом.
*C(Clock)* - тактовый импульс.
*Q(t)* - выход триггера *Qn(t)* - выход с инверсией. 
*Q(t-1)* - переведшая запись

*Схема*
![](https://digteh.ru/digital/D_trigg/04.png)
##### Таблица истинности.

| *D* | *Q(t-1)* | *Q(t)* | *Qn(t)* | *Состояние*          |
| --- | -------- | ------ | ------- | -------------------- |
| 0   | x        | 0      | 1       | Записывает 0 (Reset) |
| 1   | x        | 1      | 0       | Записывает 1 (Set)   |

#### T - Триггер (Toggle)

Это, счетный триггер. У него только один вход. Он работает так: когда на T поступает импульс, выход становиться противоположным 

*T* - вход.
*Q(t-1)* - переведшая запись
*Q(t)* - выход триггера *Qn(t)* - выход с инверсией. 

*Схема*
![](https://digteh.ru/digital/T_trigg/3.gif)

##### Таблица истинности.

| *T* | *Q(t-1)* | *Q(t)* | *Qn(t)* | *Состояние*     |
| --- | -------- | ------ | ------- | --------------- |
| 0   | 0        | 0      | 1       | Хранение 0      |
| 0   | 1        | 1      | 0       | Хранения 1      |
| 1   | 0        | 1      | 0       | Инверсия 0 -> 1 |
| 1   | 1        | 0      | 1       | Инверсия 1 -> 0 |

### Регистры.

**Регистры** - устройство, которое хранит, обрабатывает и передаёт биты данных - нолики и единицы. Внутри цифровых устройств. 

**Регистры** - это соединенные триггеры(D - триггеры, как правило). Представляют один из основных блоков в ЦПУ, Микроконтроллеров, памяти (как пример, ОЗУ или ПЗУ) 

**Почему D-триггеры**? D-триггеры способны удерживать состояния, за счёт привязки к **CLK**.
##### Виды регистров.

**Сдвиговый регистр** - последовательно передает биты данных - вправо или влево(зависит от строение регистра). По одному Биту. 

**Типы** - Сдвиг вправо, сдвиг влево и цикличный сдвиг (с возвратом бита в противоположный конец)

*Сферы применения* - Передача данных по интерфейсу SPI и I2C. Семисегментный индикатор(передача сигналов для отображения картинки). Аудио- и видеосигналы. Шифратор и Дешифратор. Цифровой фильтр.

**CLK** - Тактовый сигнал
**D** - Входной сигнал
**Q** - Выходной сигнал

| **CLK** | **D** | **Q3, Q2, Q1, Q0** |
| ------- | ----- | ------------------ |
| 0       | x     | 0000               |
| 1       | 1     | 0001               |
| 2       | 1     | 0010               |
| 3       | 1     | 0100               |
| 4       | 1     | 1000               |

То есть, при каждом входном сигнале будет записывать по значению из такта

**Обозначение** - SIPO, PISO, SISO, PIPO - **SR** 
Где 
*S* - Последовательный
*P* - Параллельный
*I* - Вход
*O* - Выход

**CLK** - Тактовый сигнал
**D** - Входной сигнал
**Q** - Выходной сигнал
**DIR** - Выбор направление в двух на правленом регистре

```Уго
		|-----------|
 CLK--->|           |--->Q3
   D--->|   SR      |--->Q2
		|           |--->Q1
		|-----------|--->Q0
```

**Двунаправленный регистр** 
```Уго
		|-----------|
 CLK--->|           |--->Q3
   D--->|   DIR     |--->Q2
 DIR--->|           |--->Q1
		|-----------|--->Q0
```
**DIR** = 0 -> Сдвиг вправо
**DIR** = 1 -> Сдвиг влево

**Параллельный регистр** - получает, сохраняет и передает биты одновременно. То есть, можно сказать что входные линии синхронизированы между собой. Как и каналы выхода. 
Но, точнее будет сказать: Выполняет операцию за один тактовый сигнал(такт). Запись данных происходит при **EN** = 1

*Сфера применения* - Хранения данных в процессорах и микроконтроллерах. Применаются в компьютерах (Основа ОЗУ). Передача данных между шинами процессора и памятью. Синхронизация сигналов в логических схемах.

**CLK** - Тактовый сигнал
**D** - Входные сигналы
**EN** - Сигнал контроля записи, если 0 нет записи(Сохраняется предыдущие значение), если 1 то будет
**Q** - Выходной сигнал

| **CLK** | **D3, D2, D1, D0** | **EN** | **Q3, Q2, Q1, Q0** |
| ------- | ------------------ | ------ | ------------------ |
| 0       | 0000               | 1      | 0000               |
| 1       | 1010               | 1      | 1010               |
| 2       | 0110               | 1      | 0110               |
| 3       | 1101               | 0      | 0110               |
| 4       | 1001               | 1      | 1001               |

**Обозначение** - **PR**

```Уго
				|-----------|
		 CLK--->|           |--->Q3
		  EN--->|   PR      |--->Q2
 D3,D2,D1,D0--->|           |--->Q1
				|-----------|--->Q0
```

**Счетный регистр** - Подсчитывает значение с определённым шагом, счёт происходит при **EN** = 1

**CLK** - Тактовый сигнал
**EN** - Разрешение на счёт
**Q** - Выходы

| **CLK** | **EN** | **Q3, Q2, Q1, Q0** |
| ------- | ------ | ------------------ |
| 0       | 1      | 0000               |
| 1       | 1      | 0001               |
| 2       | 1      | 0010               |
| 3       | 1      | 0011               |
| 4       | 1      | 0100               |
То есть, значение такта передаются по выходам в битном формате. 

**Обозначение** - `CNT↑` — счет вверх `CNT↓` — счет вниз

```Уго
		|-----------|
 CLK--->|           |--->Q3
  EN--->|   CNT     |--->Q2
		|           |--->Q1
		|-----------|--->Q0
```

*Сфера применения* - 

**Регистр сдвига и хранения** - хранит биты параллельно, а передаёт по одному при **EN** = 1    

**CLK** - Тактовый сигнал
**D** - Входной сигнал
**EN** - Сигнал контроля записи, если 0 нет записи(Сохраняется предыдущие значение), если 1 то будет
**Q** - Выходной сигнал

| **CLK** | **D** | **EN** | **Q3, Q2, Q1, Q0** |
| ------- | ----- | ------ | ------------------ |
| 0       | x     | 1      | 0000               |
| 1       | 1     | 1      | 0001               |
| 2       | 1     | 1      | 0010               |
| 3       | 1     | 1      | 0100               |
| 4       | 1     | 0      | 1000               |

От обычного регистра сдвига его отличает наличие управляющего бита для записи.

**Обозначается** - **LATCH**

```Уго
		|-----------|
 CLK--->|           |--->Q3
   D--->|   LATCH   |--->Q2
  EN--->|           |--->Q1
		|-----------|--->Q0
```
###  Мультиплексоры и демультиплексоры 

#### Мультиплексор
**Мультиплексор** - Устройство с несколькими входами. Принимает несколько сигналов и выбирает из них один в зависимости от **S(Set)**


**D** - входной сигнал
**S** - Устанавливает входы с которого принимается сигнал( цифра это индекс (от 0)).
**Y** - Выход.


| **D0** | **D1** | **S0** | **Y0** |
| ------ | ------ | ------ | ------ |
| 1      | 0      | 0      | 1      |
| 0      | 1      | 0      | 0      |
| 0      | 1      | 1      | 1      |
| 1      | 0      | 1      | 0      |

##### Формат S на разных входах.

*2 входа* - 0
*4 входа* - 00
*8 входа* - 000
*16 входов* - 0000

**Логика работы**:
Для n входов требуется ⌈log₂(n)⌉ селекторных сигналов.
Селекторная комбинация (S) в двоичной форме указывает индекс входа, который передаётся на выход Y. - Из-за этого их количество увеличается в зависимости от 
Например, для 7-входового мультиплексора при S2S1S0 = 101 (5 в десятичной системе) выход Y равен значению входа D5.

**Обозначается** - как прямоугольник с выходами *D1, D2 ... Dn* и входами *S1, S2 ... Sn*, а также с выходом *Y*

![](https://upload.wikimedia.org/wikipedia/commons/d/d8/MUX.png?20120324012013)
На схеме A = S  F = Y
Подписывается **Мультеплексор** - **MUX** или **MS**

#### Демультиплексор

**Демультеплексор** - устройство обратное от **Мультеплексора**. Оно принимает один входной сигнал и зависимости от выбранного селектора, перенаправляет на один из выходов.

**D** - входной сигнал
**S** - селектор, определяет куда пойдет входной сигнал.
**Y** - выходные сигналы

| **Вход D** | **S0** | **S1** | **Y0** | **Y1** | **Y2** | **Y3** |
| ---------- | ------ | ------ | ------ | ------ | ------ | ------ |
| 1          | 0      | 0      | 1      | 0      | 0      | 0      |
| 1          | 0      | 1      | 0      | 1      | 0      | 0      |
| 1          | 1      | 0      | 0      | 0      | 1      | 0      |
| 1          | 1      | 1      | 0      | 0      | 0      | 1      |
**Если D = 0**: то все выходы 0, независимо от селектов.
**Обозначается** - **DMS** **DM**

![](https://upload.wikimedia.org/wikipedia/commons/d/dc/DMX.png)

A = S Селекторы, D - Входной сигнал, F = Y - Выходные сигнал.
### Дешифраторы и Шифраторы

#### Дешифраторы.

**Дешифратор** - устройство, которое преобразует несколько (зависит от количества входов) сигналов множество выходных сигналов.

**Пример**:

| **Входы** | **Выходы** |
| --------- | ---------- |
| 2         | 4          |
| 3         | 8          |
| 4         | 16         |
| 5         | 32         |
| 6         | 64         |

По своей сути **Дешифратор** выполняет преобразование из двоичной системы счисление в другую, но в виде двоичных сигналов

> **Условно**:
>  101 = (1 * 2^2) + (0 * 2^1) + (1 * 2^0) = 4 + 0 + 1 = 5

| **Входы (A0, A1, A2)** | **Значение** | **Выход**                                |
| ---------------------- | ------------ | ---------------------------------------- |
| 101                    | 5            | Активируется выход 5 <br>все остальные 0 |
То есть, мы получаем входное значение *101* - оно соответствует номеру выхода и на этот выход идёт 1. Остальные 0. 

**Обозначается** DC - Decoder, прямоугольник с выходами с одной стороны (A1 A2 A4 A8) и выходами с другой (Y0, Y1, Y2... Yn) 

![](https://tablica-istinnosti.ru/wp-content/uploads/2023/07/deshif.png)

##### Пример с семисегментным индикатором.

Для семисегментного индикатора используется дешифратор с 4 входами и 7 выходами. 

| **Вход** | **Выход** | **Что выведет?** |
| -------- | --------- | ---------------- |
| 1010     | 1110111   | A                |
![](http://mbitech.ru/userfiles/image/6-1.jpg)

То есть 111 - это ABC, 0 - D , а 111 - E, F, G, 
#### Шифратор

**Шифраторы** - это устройства, которые принимают множества входным сигналов и на выходе мы получаем более компактный вывод.

**Пример**

| **Входы** | **Выходы** |
| --------- | ---------- |
| 64        | 6          |
| 32        | 5          |
| 16        | 4          |
| 8         | 3          |
| 4         | 2          |
То есть обратные **дешифратору** 

> **Условно**: принимает сигнал в бинарном формате, который указывает какая линия активна и зависимости от этого активирует выходы.

| **Входы A0, A1, A2, A3** | **Значение(Номер активной линни)** | **Выходы Y1 Y2** |
| ------------------------ | ---------------------------------- | ---------------- |
| 0001                     | 0                                  | 00               |
| 0010                     | 1                                  | 01               |
| 0100                     | 2                                  | 10               |
| 1000                     | 3                                  | 11               |


**Обознается** CD - enCoDer - прямоугольник с входами с одной стороны и выходами на другой. 

![](https://tablica-istinnosti.ru/wp-content/uploads/2023/07/shifr.png)
### Интерфейсы UART - SPI - I2C - TWI

#### UART

**UART(Universal Asynchorous Receiver-Transmitter)** - Универсальный асинхронный интерфейс, приема передачи. 
Состоит из двух линий:
**TX(Transmit)** - Передача данных
**RX(Receive)** - Прием данных

Передаёт 1 к 1 (от одного к другому)

Последовательно - по одному биту передает данные. 
Обе стороны, работают не зависимо друг от другу (Асинхронность). Но, их скорость задаётся изначально, как договор между сторонами.  (*baud rate*)
То есть, не имеет общего тактового сигнала. Также передает данные в формате, похожем на обертку - **старт-бит(0)**, затем **биты данных**, а после **стоп-бит(1)**. Они определяют где начало и конец.

**Пример формата**:

| **Стартовый бит** | **Биты данных** | **Чётность** | **Стоп Бит** |
| ----------------- | --------------- | ------------ | ------------ |
| 0                 | 010101001       | Опционально  | 1            |
**Стартовый бит** - всегда 0: начало.
**Биты данных** - обычно до одного Байта: данные для передачи.
**Бит чётности** - нужен для проверки на ошибки.
**Стоп-бит** - всегда 1: заканчивает передачу.

#### USART

**USART** - это расширенный **UART**. Отличатся тем, что поддерживает синхронную связь (общий такт). Является **универсальным асинхронно-синхронным интерфейсом, приема передачи**. 

Также как и **UART**, имеет две линии. **TX** - Передача **RX** - Прием данных

Передаёт 1 к 1 (от одного к другому)

**USART** - Является интерфейсом связи с устройствами
#### SPI

**SPI(Serial Peripheral Interface)** - Серийно-периферийный интерфейс. 

Состоит из 4 линий.
И двух основных ролей.
*Slave* - Ведомый.
*Master* - Ведущий.
Связь: один *Master* много *Slave*

У **Slave**  нет адресов. Для выбора ведомого используется **SS/CS** - биты, которые определяют какой **Slave** выбран

| **Аббревиатура ** | **Название**               | **Как работает**              |
| ----------------- | -------------------------- | ----------------------------- |
| MOSI              | *Master* Out, *Slave* In   | Сигнал от ведущего к ведомому |
| MISO              | *Master* In, *Slave* Out   | Сигнал от ведомого к ведущему |
| SCLK              | Serial Clock               | Тактовый сигнал               |
| SS/CS             | *Slave* Select/ Chip Selct | Выбор конкретного ведомого.   |
**SPI** - Является интерфейсом связи между устройством и периферией.  
#### I2C 
**I2C(Inter-Integrated Circuit)** - Интерфейс связи между микросхемами.

Имеет две линий 
*SDA(Data)* - Данные.
*SCL(Clock)* - Тактовый сигнал (синхронизации).

Работает по принципу **Master - Slave** (От ведущего к ведомому)
Передаёт 1 к многим (от одного к многим)

Каждый **Slave** имеет свой адрес (набор битов, определяющих куда пойдет сигнал)
Последовательный-синхронный. 
Выполняет все поочередно, обращаясь к каждой подключенной схеме по отдельности. 
Поддерживает до 128 подключенных устройств с уникальными адресами.

Имеет несколько режимов работы, которые отличаются по скорости работы
*Standard Mode:* до 100 kHz  
*Fast Mode:* до 400 kHz  
*Fast Mode Plus:* до 1 MHz  
*High-Speed Mode:* до 3.4 MHz  

**Как работает**:

**Инициализация**: Мастер генерирует сигнал начала (Start condition) — **SDA** переходит от высокого к низкому уровню при высоком тактовом сигнале **SCL**.

**Адресация**: Мастер отправляет адрес слейва (7 или 10 бит) и бит чтения/записи (R/W).

**Передача данных**: Слейв подтверждает **ACK** или отклоняет **NACK** адрес, после чего данные передаются по байтам с подтверждением после каждого.

**Завершение**: Мастер генерирует сигнал окончания (Stop condition) — **SDA** переходит от низкого к высокому при высоком **SCL**.

**I2C** - Является интерфейсом связи между устройством и периферией.  
##### TWI - альтернативное название I2C

**Используется** - Альтернативное название **TWI(Two - Write - Interface)** появилось для обхода лицензии на термин **I2C** 

Тоже имеет две линии
*SDA(Data)* - Данные.
*SCL(Clock)* - Тактовый сигнал (синхронизации).

Работает по принципу **Master - Slave** (От ведущего к ведомому)

Последовательный-синхронный. 
Выполняет все поочередно, обращаясь к каждой подключенной схеме по отдельности. 
Поддерживает до 128 подключенных устройств с уникальными адресами.

Имеет несколько режимов работы, которые отличаются по скорости работы
*Standard Mode:* до 100 kHz  
*Fast Mode:* до 400 kHz  
*Fast Mode Plus:* до 1 MHz  
*High-Speed Mode:* до 3.4 MHz  

**Как работает**:

**Инициализация**: Мастер генерирует сигнал начала (Start condition) — **SDA** переходит от высокого к низкому уровню при высоком тактовом сигнале **SCL**.

**Адресация**: Мастер отправляет адрес слейва (7 или 10 бит) и бит чтения/записи (R/W).

**Передача данных**: Слейв подтверждает **ACK** или отклоняет **NACK** адрес, после чего данные передаются по байтам с подтверждением после каждого.

**Завершение**: Мастер генерирует сигнал окончания (Stop condition) — **SDA** переходит от низкого к высокому при высоком **SCL**.

**TWI** - Является интерфейсом связи между устройством и периферией.  
### Транзисторная логика и описание типового микропроцессорного устройства

**Транзистор** - элемент любой электро цепи. Можно представить в виде переключателя (крана), который выключает и включает поток тока, а также может его усиливать.
Имеет три ножки
**База** - управляющая
**Коллектор** - точка входа
**Эмиттер** - точка выхода

Сигнал идущий на базу определяет идёт ток или нет. Если ток на **Базу** идёт, то **Коллектор** будет пропускать ток до **Эмиттера**
 
**Транзисторная логика** - так называют электрические схемы, где логические элементы построены на транзисторах. Логические элементы и построены на транзисторах и их взаимосвязь осуществляется через транзисторы.

**Транзистор-транзисторная логика** - это реализация логических элементов с помощью биполярных транзисторов и резисторов. Это один из вариантов реализации транзисторной логики. (Ещё есть диодно-транзисторная логика, где входные сигналы обрабатывали диоды)


### Арифметико-логическое устройство (АЛУ)

**АЛУ** - Арифметеко-логическое устройство. Устройство, что выполняет логические операции (Всего 15 логических операций), арифметические операции (Тоже 15 операций). Всего 30 операции.
**АЛУ** - является одним из блоков в **ЦПУ** 

**Логические операции (15)**:
ИЛИ
И
НЕ
Исключающие ИЛИ
По битное ИЛИ - логическая операция ИЛИ по битам
По битное И - логическая операция И по битам
По битное НЕ - логическая операция НЕ по битам
По битное Исключающие ИЛИ - логическая операция Исключающие ИЛИ по битам
Равенство
Неравенство
Проверка - нулевое ли число, отрицательное или положительное.
Маскировка Битов - выбирает один из битов 
Операция сдвигов - перемещает биты в одну из сторон, влево на право - право на влево
Ротация битов - цикличная операция сдвигов
Тестирование битов - проверяет бит. 1 или 0

**Арифметические операции (15)**:
Сложение
Вычитание
Умножение
Деление
Инкремент (+1) - увеличивает значение на единицу
Декремент (-1) - уменьшает значение на единицу
Абсолютное значение - преобразование числа в положительное
Умножение с округлением
Деление с остатком
Операции с плавающей запятой - для работы с дробными числами в специальном формате например IEEE - 754(Специальный формат для работы с дробными числами чисел)
Перевод между разными форматами чисел
Нахождение максимального/минимального значения - сравнение максимальных чисел и минимальных 
Сравнение чисел - равны ли числа
Пересчет знака - заменяется знак числа, 5 станет -5
Побитовый сдвиг - перемещение битов чисел

```УГО АЛУ
		A <---|-----------------|
		B <---|                 |
		OP<---|       ALU       |--- > Result 
			  |                 |
			  |-----------------|

```

**A** - Входной операнд
**B** - Входной операнд
**OP** - Код операции / Управляющий входом - Как правило, принимает от двух до 8 битов (Зависит от сложности АЛУ) 
**Result** - Результат операции

**Уточнение**: Для 30 операций хватает и 5 битов на **OP**, но 8 битов является оптимальным, так как два бита остаются для дополнительных операций - Округление, Пересчет знаков и так далее. Такие биты называются *дополнительные флаги состояния*

 > **Примечание** 4-разрядное АЛУ - это АЛУ, которое принимает *Входных операндов* в 4 битном формате. То есть, четыре бита с двоичными цифрами. 





### Сумматор и Полусумматор.

#### Сумматор

**Сумматоры** - логическое устройство, которое выполняет логические операции. Выполняет сложение трёх битов.

Двух входных **A** и **B**
и Переносимого от предыдущего разряда **Cin**.
**Sum** - Исключающие ИЛИ.
**Carry** - И + ИЛИ (**A** and **B**) or (**A** and **Cin**) or (**B** and **Cin**) - Это бит переноса **Cin** - *Carry_in*.
**Carry** - Равен 1, если два входа и более 1, Но если все входы 1 то и **Sum** единица

| **A** | **B** | **Cin** | **Sum** | **Carry** |
| ----- | ----- | ------- | ------- | --------- |
| 0     | 0     | 0       | 0       | 0         |
| 0     | 0     | 1       | 1       | 0         |
| 1     | 0     | 0       | 1       | 0         |
| 1     | 1     | 0       | 0       | 1         |
| 0     | 1     | 1       | 0       | 1         |
| 1     | 1     | 1       | 1       | 1         |
| 1     | 0     | 1       | 0       | 1         |
| 0     | 1     | 0       | 1       | 0         |



**Обознается**. прямоугольники с SUM  и тремя входами **A** **B** **Cin**. входов может быть и больше зависит от количество переносимых битов.  А, также два выхода **S(Sum)** и перенос **P(Carry_in)** на противоположной стороне.


![](http://informatics-lesson.ru/images/logic/summator.png)


#### Полусумматор

**Полусумматоры** - устройство выполняющие логическое сложение, без учета переноса. Отсутствует входящий сигнал **Carry_in**
То есть, у него только два входных значения **A** и **B**

| **A** | **B** | **Sum** | **Carry** |
| ----- | ----- | ------- | --------- |
| 0     | 1     | 1       | 0         |
| 1     | 0     | 1       | 0         |
| 0     | 0     | 0       | 0         |
| 1     | 1     | 0       | 1         |

![](http://informatics-lesson.ru/images/logic/polusum.png)

**Обознается**. прямоугольники с SUM  и двумя входами **A** **B**.
 А, также два выхода **S(Sum)** и перенос **P(Carry_in)** на противоположной стороне.






