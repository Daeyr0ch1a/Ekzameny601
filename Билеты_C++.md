### Теория (Билеты с  определением)

#### №1.1
**Двоичная система исчисления** - это система, в которой существует только 1 и 0.
Используется в цифровом формате, поскольку легко реализуема на аппаратной логике в виде: есть ток - нет тока.
Из этого происходит, что один бит (Минимально возможная единица хранящая информацию для цифровых устройств) - может быть равна или 1, или 0.

Логическое представление: в логических условия - True\False(1\0).

**Перевод в десятичную и обратно**;
С двоичного в десятичную осуществляется так, на примере числа 1011.
```
1 = 2^0 - 1 * 2^0 = 1
1 = 2^1 - 1 * 2^1 = 2
0 = 2^2 - 1 * 2^2 = 4
1 = 2^3 - 1 * 2^3 = 8
1 + 2 + 4 + 8 = 15
```

С десятичной в двоичную осуществляется так, на примере числа 16.
```
16 / 2 = 8 - остатка нет - 0
8 / 2 = 4 - остатка нет - 0
4 / 2 = 2 - остатка нет - 0
2 / 2 = 1 - остатка нет - 0
1 / 2 = 0 - остаток - 1

10000
```

#### №2.1
**Двоично - шестнадцатеричная система.** - Способ сделать бинарный код более компактным. Каждый символ шестнадцатеричной состоит из 4 бинарных символов.

*Перевод* - По этому перевод можно описать как 2 в 4 степени равна 16. Но, если двоичное число, не состоит из 4 цифр, то в конце добавляется 0. 
Пример, есть число 110100011011. Мы делим число на четырехзначные числа и получаем. 

```
Пример на одной группе:
1101 -> D
0001 -> 1
1011 -> B
```    

**Описание** - Шестнадцатеричная система исчисления. Состоит из 16 символов; цифр от 0 до 9 и латинские буквы с A по F. Применяется для передачи данных, так как позволяет передать большое количество двоичных символов компактной форме. Пример, HEX коды - это код, по которому выдается цвет. Код состоит из трех Байтов - 24 бита. Вид кода `#FFFFFF` - это белый.

**Перевод шестнадцатеричного числа в десятичную и назад.**;

На примере 165BD
```
165BD = (1 * 16)^4 + (6 * 16)^3 + (5 * 16)^2 + (11 * 16)^1 + (13 * 16)^0 = 65536 + 24576 + 1280 + 176 + 13 = 91 581
```

```
91581 / 16 = 5723 - остаток 13(D)
5723 /16 = 357 - остаток 11(B)
357 / 16 = 22 - остаток 5
22 / 16 = 1 - остаток 6
1 / 16 = 0 - остаток 1
```
#### № 2.2 
**Микроконтроллеры. Описание** - Компактное цифровое устройство или микросхема, которое может выполнять программируемые операции. Также называют - *Однокристальный компьютер*, так как они обладают основными для ЭВМ характеристиками.

Используется там где обычный компьютер это излишне - автоматизация мелких процессов в бытовых устройствах, как пример.

Микроконтроллеры, имеют разные архитектуры - как и процессоры для обычных ЭВМ. Также как и обычный ЭВМ имеет периферию и интерфейсы для их подключения  UART. I2C. SPI. CAN. USB. IEEE.

Как было упомянуто, у микроконтроллеров разные архитектуры. Такие как: RISC(AVR, ARM), CISC(x86), Гарвардская и фон Неймана.

*RISC* (Архитектура командного набора/набора команд) - упрощенная архитектура, быстрее за счет коротких команд. Из-за этого не может выполнять сложные команды(несколько в одном). Не имеют доступа к памяти(полноценно, если сравнивать с *CISC*(через операции с памятью `LOAD STORE`. Загрузка и хранение)). 

*CISC* (Архитектура командного набора/набора команд) - полноценная архитектура. Инструкции более сложные, чем у *RISC*. Команды могут быть сложными(составными). Может обращаться к памяти.

*Гарвардская архитектура* (Архитектура памяти) - по сути, это разделение чтения команд и их выполнения(две разные шины). Была разработана как альтернатива *архитектуры фон Неймана*. Отличалась, отсутствием эффекта узкого горлышка бутылки, когда нужно выполнить чтение и произвести операцию.

*Архитектура Неймана* (Архитектура памяти) - линейная архитектура(одна шина). Мы вводим команды они предаются *ЦП*, читаются *УУ* и выполняются *АЛУ*, а при выполнении сохраняются в памяти. После выполнения производится вывод.   

*Архитектура командного набора/набора команд* - вид команд, то как они выполняются, какие есть в принципе.

*Архитектура памяти* - Организация памяти, то как оно взаимодействует с компонентами устройства. 

#### Логические элементы. (N3.1 по 30.1)

*Цифры в названии* - количество входов; сколько одно битных сигналов может принять элемент.

 **НЕ**_(NOT)_ - один вход принимает один сигнал и инвертирует его в противоположный (0 -> 1 или 1 -> 0).

 **2 И**_(AND)_ - два входа, ожидает когда оба будут идентичны. Если же не идентичны выдаст 0.

**2 ИЛИ(OR)** - два входа, если на хотя бы на одном единица, то на выходе единица, если оба ноль будет ноль.

**2 Исключающие ИЛИ(XOR)** - два входа, похож на _ИЛИ_, но если на обоих входах 1 выход будет 0 

**2 Исключающие ИЛИ-НЕ(XNOR)** - два входа, похож на обычное _XOR_, но выход в инверсии.

**2 И-НЕ(NAND)** - два входа, ожидает, что оба будут единицей. Если оба будут единицей выйдет 0 - если нулями то 1.  

**2 ИЛИ-НЕ** - два входа, ожидает, что хотя бы одни из них будет единицей. Если один из них единица выход 0 - если оба нули, то 1.
### Графическое Обозначение и Таблица истинности.

#### Логические элементы.

**НЕ(NOT)** - Треугольник или квадрат(Прямоугольник), с кружком на выходе.

![](https://electricalschool.info/uploads/posts/2017-08/1503050369_6.gif)

*Таблица истинности для НЕ*:

| X1  | Y   |
| --- | --- |
| 0   | 1   |
| 1   | 0   |

**И(AND)** - Прямоугольник с символом _&_. Либо D-образная фигура, плоская сторона входы.

![](https://electricalschool.info/uploads/posts/2017-08/1503050305_2.gif)

_Таблица Истинности для 2 И_:

| X2  | X1  | Y   |
| --- | --- | --- |
| 0   | 1   | 0   |
| 1   | 1   | 1   |
| 1   | 0   | 0   |
| 0   | 0   | 0   |

**Исключающие ИЛИ(XOR)** - Прямоугольник с символом _=1_. Либо D-образная фигура, но перед плоской стороной изогнута линия.

![](https://electricalschool.info/uploads/posts/2017-08/1503050362_12.gif)

| X2  | X1  | Y   |
| --- | --- | --- |
| 0   | 1   | 1   |
| 1   | 1   | 0   |
| 0   | 0   | 0   |
| 1   | 0   | 1   |

**ИЛИ(OR)** - Прямоугольник с символом _Больше или равно 1_. Либо D-образная фигура, но линяя входов выпуклая.

![](https://electricalschool.info/uploads/posts/2017-08/1503050277_4.gif)

| X2  | X1  | Y   |
| --- | --- | --- |
| 1   | 1   | 1   |
| 0   | 1   | 1   |
| 0   | 0   | 0   |
| 1   | 0   | 1   |

**Исключающие ИЛИ-НЕ(XNOR)** - Прямоугольник с символом _=1_ и кружок на выходе. Либо D-образная фигура, но перед плоской стороной изогнута линия и на выходе кружки.

| X2  | X1  | Y   |
| --- | --- | --- |
| 1   | 1   | 0   |
| 0   | 0   | 1   |
| 1   | 0   | 0   |
| 0   | 1   | 0   |

**И-НЕ(NAND)** - Прямоугольник с символом _&_ и кружком на выходе. Либо D-образная фигура с кружном на выходе.

| X2  | X1  | Y   |
| --- | --- | --- |
| 1   | 1   | 0   |
| 0   | 0   | 1   |
| 1   | 0   | 1   |
| 0   | 1   | 1   |

**ИЛИ-НЕ(NOR)** - Прямоугольник с символом _Больше или равно 1_ и кружком на выходе. Либо полусфера где выход на плоской, а входы на выпуклой.

| X2  | X1  | Y   |
| --- | --- | --- |
| 1   | 0   | 0   |
| 0   | 0   | 1   |
| 1   | 1   | 1   |
| 0   | 1   | 0   |



#### Общая таблица логических элементов.

![](https://electricalschool.info/uploads/posts/2022-07/1657614877_1.jpg)

### Триггеры билеты №8-12, 25-30.

#### RS -Триггер (Reset-Set)

**Схема**
![](https://digteh.ru/CVT/trigg/02.gif)

По сути, этот триггер имеет два входа *S* и *R*. По *S* задается значение - если по нему один он его сохраняет. А *R* же, сбрасывает значение, если по нему идет единица. 

*S(Set)* - Устанавливает 1.
*R(Resets)* - сбрасывает до 0.

*Q(t)* - выход триггера *Qn(t)* - выход с инверсией. 

##### Таблица истинности.

| *S* | *R* | *Q(t)*         | *Qn(t)*        | *Состояние*                       |
| --- | --- | -------------- | -------------- | --------------------------------- |
| 0   | 1   | 0              | 1              | Состоянии (0) сброса.             |
| 1   | 0   | 1              | 0              | Состоянии (1) установка (задает). |
| 1   | 1   | Неопределённое | Неопределённое | Запрещенное состояние.            |
| 0   | 0   | Q(t-1)         | Qn(  t-1)      | Хранения.                         |


#### JK - Триггер.

Версия *RS - триггера* без запрещенного состояния.
Считается универсальным - позволяет реализовать на себе логику любого триггера

*J(Set)* - устанавливает единицу.
*K(Reset)* - сбрасывает.
*C(Clock)* - тактовый сигнал.
*Q(t)* - выход триггера *Qn(t)* - выход с инверсией. 

*Схема*
![](https://digteh.ru/digital/JKtrigg/06.gif)


| *J* | *K* | *Q(t-1)* | *Q(t)* | *Qn(t)* | *Состояние*     |
| --- | --- | -------- | ------ | ------- | --------------- |
| 0   | 0   | Q(t-1)   | Q(t-1) | Q(t-1)  | Хранение        |
| 0   | 1   | 1        | 0      | 1       | Сброс           |
| 1   | 0   | 0        | 1      | 0       | Установка       |
| 1   | 1   | 0        | 1      | 0       | Инверсия 0-> 1  |
| 1   | 1   | 1        | 0      | 1       | Инверсия 1 -> 0 |

#### D - триггер.

Сигнал входит в *C*, а *D* просто копирует сигнал.
*D* = *C*

*D(Delay)* - вход с импульсом.
*C(Clock)* - тактовый импульс.
*Q(t)* - выход триггера *Qn(t)* - выход с инверсией. 
*Q(t-1)* - переведшая запись

*Схема*
![](https://digteh.ru/digital/D_trigg/04.png)
##### Таблица истинности.

| *D* | *Q(t-1)* | *Q(t)* | *Qn(t)* | *Состояние*          |
| --- | -------- | ------ | ------- | -------------------- |
| 0   | x        | 0      | 1       | Записывает 0 (Reset) |
| 1   | x        | 1      | 0       | Записывает 1 (Set)   |

#### T - Триггер (Toggle)

Это, счетный триггер. У него только один вход. Он работает так: когда на T поступает импульс, выход становиться противоположным 

*T* - вход.
*Q(t-1)* - переведшая запись
*Q(t)* - выход триггера *Qn(t)* - выход с инверсией. 

*Схема*
![](https://digteh.ru/digital/T_trigg/3.gif)

##### Таблица истинности.

| *T* | *Q(t-1)* | *Q(t)* | *Qn(t)* | *Состояние*     |
| --- | -------- | ------ | ------- | --------------- |
| 0   | 0        | 0      | 1       | Хранение 0      |
| 0   | 1        | 1      | 0       | Хранения 1      |
| 1   | 0        | 1      | 0       | Инверсия 0 -> 1 |
| 1   | 1        | 0      | 1       | Инверсия 1 -> 0 |

#### Регистры.
**Регистры** - устройство, которое хранит, обрабатывает и передаёт биты данных - Нолики и единицы.

##### Виды регистров.

**Сдвиговый регистр** - последовательно передает биты данных. По одному Биту.

*Сферы применения* - Передача данных по интерфейсу SPI и 12C. Семисегментный индикатор(передача сигналов для отображения картинки). Аудио- и видеосигналы. Шифратор и Дешифратор. Цифровой фильтр.

**Параллельный регистр** - загружает все, возможные, биты данных. 

*Сфера применения* - Хранения данных в процессорах и микроконтроллерах. Приминаются в компьютерах (Основа ОЗУ). Передача данных между шинами процессора и памятью. Синхронизация сигналов в логических схемах.

**Счетный регистр** - измеряет значения - как цикл с определённым шагом.

*Сфера применения* - 

**Регистр сдвига и хранения** - соединяет несколько парадигм. Хранит данные до прихода нового сигнала.


###  **Мультиплексоры и дешифраторы** (билеты №19, 22, 24)

#### Мультиплексор
**Мультиплексор** - Устройство с несколькими входами. Принимает несколько сигналов и выбирает из них один в зависимости от **S(Set)**

**A**, **B** - Входы.
**S** - Устанавливает входы с которого принимается сигнал( цифра это индекс (от 0)).
**Y** - Выход.


| **A** | **B** | **S** | **Y** |
| ----- | ----- | ----- | ----- |
| 1     | 0     | 0     | 1     |
| 1     | 0     | 1     | 0     |
| 0     | 1     | 0     | 0     |
| 1     | 0     | 1     | 0     |

#### Формат S на разных входах.

*2 входа* - 0
*4 входа* - 00
*8 входа* - 000
*16 входов* - 0000

#### Дешифраторы.

**Дешифратор** - устройство де-компоновщик, он получает несколько компактных сигналов.
Получает сигнал из двух и более битов и, в зависимости от сигнала определяет на какой выход подаётся сигнал. 

| **Вход** | **В десятичной системе** | **Какой выход активный** |
| -------- | ------------------------ | ------------------------ |
| 10       | 2                        | Y2=1                     |
| 01       | 1                        | Y1=1                     |
| 00       | 0                        | Y0=1                     |
| 11       | 3                        | Y3=1                     |

**Формула**: Сколько выходов 2^n 
*n* - количество входов.

*НО*, не смотря на это для семисегментного индикатора - это не 16 выходов. 2^4 = 16
4 входа - 7 выходов, на каждый сегмент.
Потому что, этот дешифратор специализирован.

| **Вход** | **Цифра** | **Сегменты**  |
| -------- | --------- | ------------- |
| 0000     | 0         | A B C D E F   |
| 0001     | 1         | B C           |
| 0010     | 2         | A B D E G     |
| 0011     | 3         | A B C D G     |
| 0100     | 4         | B C F G       |
| 0101     | 5         | A C D F G     |
| 0110     | 6         | A C D E F G   |
| 0111     | 7         | A B C         |
| 1000     | 8         | A B C D E F G |
| 1001     | 9         | A B C D F G   |

### UART - SPI - 12C

#### UART

**UART(Universal Asynchorous Receiver-Transmitter)** - Универсальный асинхронный интерфейс, приема передачи. 
Состоит из двух линий:
**TX(Transmit)** - Передача данных
**RX(Receive)** - Прием данных

Последовательно - по одному биту передает, передает данные. 
Обе стороны, работают не зависимо друг от другу (Асинхронность). Но, их скорость задаётся изначально, как договор между сторонами.  (*baud rate*)
То есть, не имеет общего тактового сигнала. Также передает данные в формате, похожем на обертку - **старт-бит(0)**, затем **биты данных**, а после **стоп-бит(1)**. Они определяют где начало и конец.

**Пример формата**:

| **Стартовый бит** | **Биты данных** | **Чётность** | **Стоп Бит** |
| ----------------- | --------------- | ------------ | ------------ |
| 0                 | 010101001       | Опционально  | 1            |
**Стартовый бит** - всегда 0: начало.
**Биты данных** - обычно до одного Байта: данные для передачи.
**Бит чётности** - нужен для проверки на ошибки.
**Стоп-бит** - всегда 1: заканчивает передачу.

#### SPI

**SPI(Serial Peripheral Interface)** - Серийно-периферийный интерфейс. 

Состоит из 4 линий.
И двух основных ролей.
*Slave* - Ведомый.
*Master* - Ведущий.
Связь: один *Master* много *Slave*

| **Аббревиатура ** | **Название**               | **Как работает**              |
| ----------------- | -------------------------- | ----------------------------- |
| MOSI              | *Master* Out, *Slave* In   | Сигнал от ведущего к ведомому |
| MISO              | *Master* In, *Slave* Out   | Сигнал от ведомого к ведущему |
| SCLK              | Serial Clock               | Тактовый сигнал               |
| SS/CS             | *Slave* Select/ Chip Selct | Выбор конкретного ведомого.   |

#### I2C 
**I2C(Inter-Integrated Circuit)** - Интерфейс связи между микросхемами.

Состоит из двух линий 
*SDA(Data)* - Данные.
*SCL(Clock)* - Тактовый сигнал (синхронизации).

Последовательный-синхронный. 
Выполняет все поочередно, обращаясь к каждой подключенной схеме по отдельности. Поддерживает до 128 подключенных устройств с уникальными адресами.



