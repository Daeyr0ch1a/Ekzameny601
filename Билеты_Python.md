### Типы данных, операторы, переменные, константы
#### Типы данных.

| *Типы*        | *Обозначения* | *Примеры*                         |
| ------------- | ------------- | --------------------------------- |
| Целочисленный | int           | (42, -7)                          |
| Дробный       | float         | (3.14, 0.1)                       |
| Строковый     | str       | "Привет"                          |
| Логический    | bool          | True/False                        |
| Список        | list          | `[1, 2, 3] ["apple"]`             |
| Кортежи       | tuple         | (1, 2, 3)                         |
| Словарь       | dict          | {"name":"Alice", "number": "123"} |
| Множества     | set           | {1, 2, 3}                         |
| Ничего        | NoneType      | None                              |
*Типы можно*: создавать через классы

#### Операторы

| *Что делает?*                      | *Вид*   | *Пример*                                |
| ---------------------------------- | ------- | --------------------------------------- |
| Сложение                           | +       | `print(a + b)`                          |
| Вычитание                          | -       | `print(a - b)`                          |
| Умножение                          | *       | `print(a * b)`                          |
| Деление                            | /       | `print(a / b)`                          |
| Целочисленное деление(без остатка) | //      | `print(a // b)`                         |
| Возведение в степень               | **      | `print(a ** b)`                         |
| Остаток от деления                 | %       | `print(a % b)`                          |
| Больше/меньше                      | `>/<`   | `print(a > b)`    `print(a < b)`        |
| Больше/меньше или равно            | `>=/<=` | `print(a >= b)`        `print(a <= b)`  |
| Равно/Не равно                     | ==/!=   | `print(a == b)`         `print(a != b)` |
##### Логические Опрерации.

| *Что делает?*                 | *Вид* | *Пример*                |
| ----------------------------- | ----- | ----------------------- |
| Логическое сложение           | and   | `print(True and False)` |
| Логическое ИЛИ                | or    | `print(True or False)`  |
| Логическое отрицание/Инверсия | not   | `print(not True)`       |
#### Переменная

```Python
name = "Alice"
age = 25
height = 1.75
is_student = True
```
#### Константы

**Константы в Python** - их нет, но по правилам считается переменная названная полностью заглавными буквами.
Ещё есть вариант через модуль `typing`

```Python
from typing import Final

NUMBER: Final = 9.11

```

### Ветвления **if** - **elif** - **else**.


**if** - Блок кода, который выполняется, если условие в заголовке True.

```Python
a = 1
if(a == 1):
	print("Hello")

```

**Вывод**: `Hello`

**elif** - Блок кода, который выполняется, если условие в заголовке **if**  - False 

```Python
a = 25
if(a == 21):
	print("Hello")
elif(a == 25):
	print("Bye")
```

**Вывод**: `Bye` 

**else** - Блок кода, который выполняется, если в **if** условие - False. Но, у **elif**, своё условие.           У **else** нет условия для выполнения, он выполняется если **if** или **elif** - False

```Python
a = 26
if(a == 88):
	print("Hello")
elif(a == 99):
	print("Bye")
else:
	print("What?")
```

**Вывод**: `What?`

### Циклы **for** - **while**.

**for** - Цикл перебирания интерируемого объекта(Списки, кортежи, массивы, строки, диапазон range()). Выполняется фиксированное количество раз. 

**Пример**:

```Python
a = 5
for i in range(a):
	print(i)
```

Выводит от 0 до 4, так как **range()** не учитывает врехнию границу

**while** - Цикл с условием. **if** - выполняемый несколько раз (Выполняется пока условие **True** - когда False прекратится). 

**Пример**:

```Python
a = int(input())
while a:
	if a == 5: 
		print("True")
		break
	else:
		print("False")
		a = int(input())
```

Вводится число, если оно ведено, проверяет равно ли оно пяти, если нет выводит **False** и запрашивает новое значение. Оно водится и слова проверяется, если 5, выводится **True** и цикл завещается. 

Но, **while a:** Запускается если **a** не 0 или None.

#### **while** Без условия входа

**Бесконечный цикл**
	**while** **True**:
	Будет выполняться бесконечно, если внутри нет условия для выхода.  

**while** Без условия входа. С ложным условием или если оно отсутствует, цикл не выполнится не разу 

### Модули и Пакеты, а также их подключение.

**Модули** - В **Python**. Это любой файл с расширением `.py` 

```Python
import name_module # Полностью импортируем весь код модуля
from name_module import Class #Конкретный класс или функцию или метод или объект.
```

**Пакеты** -  В **Python**. Это директория с файлами с расширением `.py` и модулем `__init__.py`  - просто указывает на то, что это пакет.

### Ввод с клавиатуры 

```Python
a = input() #Ждёт ввода
```

### Проверка строки - Алфавитно-цифровая

```Python
S.isalnum() #S строка 
```

### Кортежи и Списки

**Списки** - изменяемый тип данных.

```Python
List_a = []
```

**Кортежи** - Неизменяемый тип данных

```Python 
Tuple_a = ()
```

### range()

**range()** - это функция, которая создает объект типа **range**, последовательность чисел
**range(1, 6, 2)**
1 - **start** - С какого числа начнёт. (Необязателен, по умолчанию 0  ) 
6 - **stop** - До какого дойдет. (Обязателен)
2 - **step** - Какой шаг. (Необязателен, по умолчанию 1 )

То есть вывод будет 
```
1
3
5
```

### Локальные и глобальные переменные.

**Локальная переменная** - внутри функции.
**Глобальная переменная** - Не находится внутри чего либо.

### Func и Func()

**Func** - ссылка на функцию. 
**Func()** - вызов функции.

### map()

**map()** - функция, которая позволяет применить, что-то к конкретным значениям в структуре 

### Передача значений

**Для изменяемых** объектов(списки, словари) - по ссылке.
**Для неизменяемых** объектов(числа, строки) - по значению

### Разворот цикла

Можно через цикл **for** и обратной индексацией. Начинает с последнего элемента и через += сохраняет в другом списке

```Python
for i in range(-1, len(List_a)-1, -1, -1):
	List_b += List_a[i]
```

Можно с помощью функции **reverse()**

```Python
List_a.reverse()
```

Можно просто развернуть список и записать его в другой

```Python
List_b = List_b[::-1]
```

### Что такое self.?

**self.** - это ссылка на экземпляр объекта в классе.

```Python
class person:
	def __init__(self, name):
		self.name = name
	def SayName(self):
		print(self.name)

Prn = person("Влад")
Prn.SayName()
```

### Объединение списков.

Можно так:

```Python
List_a + List_b
```

Можно так:

```Python
List_a.extend(List_b)
```

### Списки и Массивы

**Списки** - стандартный тип в **Python**. Хранит элементы разных типов - изменяемые и динамичные
**Массивы** - из модуля `array` . Только элементы одного типа. - быстрые и экономят память

### Изменяемые и неизменяемые объекты.

**Неизменяемые**:
Int - целочисленный тип
float - дробный/вещественный
tuple - кортеж
bool - логический (True/False)
str - строковый
frozenset - множество

**Изменяемые**:
list - список
dict - словарь
set - множество
bytearray - байтовый массив

### Функция округления round()

**round()** - Округляет до определенного значения после запятой

**Пример**
```Python
round(3.11111, 2) # 3.11
round(3.11111, 0) # 3
```

### Что быстрее, словарь или список?

**Словарь**, потому, что поиск осуществляется по ключу O(1)
В **Списке** по значению O(n)

### Модули и пакеты

**Модуль** - любой файл с расширением `.py`. Можно импортировать через `import module` или `from modele import class`
**Пакет** - папка с файлами, с расширением  `.py` и для того, чтобы папка была пакетом  нужен `__init__.py`, внутри папки. Можно импортировать по `import direct_name.modele` или `from direct_name.module import class`

### Уменьшить/увеличьте значение 

```Python 
x += 1 # Увеличиваем
x -= 1 # Уменьшаем
```

### Проверка наличия значения в списке

```Python
if value in list_a:
	print(True)
```

**Пример**

```Python
value = "Max"

list_a = ["value", "Max", "I`m sigma"]

if value in list_a:

	print(Max)
```

### append() и extend()

**append()** - Добавляет элемент в конец списка

**extend()** - Добавляет в список всё значения коллекции, предварительно распаковав их (разделив на отдельные элементы)

### pass, continue, break

**pass** - заглушка, ничего не делает.
**continue** - пропускает одну итерацию.
**break** - завершает всё, ломает процесс.

```python
for i in range(5):
    if i == 2:
        continue  # пропустит 2
    if i == 4:
        break     # завершит цикл
    print(i)
```

**Вывод**
- 0
- 1
- 3

### Основные типы данных

**int** - целочисленный
**float** - вещественный
**str** - строковый
**bool** - логический
**list/dict/tuple** - структуры.

### Обработка исключения

```Python 
try:
	# Повторяет выполнение, не смотря на ошибки
except # Здесь должно быть прописано, какие ошибки он ищет ValueError ловет всё ошибки:
	# Обработка ошибки, выполняется если ошибка
finally: 
	# Выполняет, что угодно всегда 
```

### Tkinter и создание кнопки в нём

**tkinter** - модуль GUI для Python. Стандартный.

**Пример**: Создание кнопки.

```Python
import tkinter as tk

win = tk.Tk()
button = tk.Button(win, text="Да", command=SayOk)
button.pack()
win.mainloop()
```

### Элементы в Tkinter

**Label** - текстовая метка. Место с текстом.
**Entry** - Поле для ввода.
**ChexButton** - Кнопка, как флаг.
**RadioButton** - Кнопка, как флаг, но выбрать можно только одну
**Scrollbar** - Кнопка на отдельной линии, позволяет перемещаться по вертикали и горизонтали.

### SQLite3

**Для того**, чтобы начать работать с SQLite внутри **Python**, нужно; импортировать модуль `sqlite3`, прописать `connect()` - путь к БД, также объявить `cursor()` и прописывать SQL запросы внутри метода `execute()`

### Поддержка ООП

**Python** - мультипарадигменный язык, он поддерживает и **Функциональную**, и **Императивную**, и **Объектно-ориентированную** 

**Инкапсуляция** - выражается сокрытием внутренней логики. К примеру, в классах, можно сокрыт имена через `___имя_параметра`  

**Полиморфизм** - Классы и объекты, могу наследовать один общий класс - это и есть проявления **Полиморфизма**

**Наследование** - Классы могу наследовать другие классы.

Также в **Python** объекты создаются с ссылкой на классы.

### Ключи в классе.

**Ключ в словаре** - это любой не изменяемый объект (int, str,)

### Метод `__init__`

**Метод __init__** - это конструктор класса, метод который вызывается автоматически при создании объектов. Специальный метод внутри класса, обычно в нём прописан `self.`, который является ссылкой на параметр в классе 

**Пример**

```Python
class cat():
	def __init__(self, name):
		self.name = name
	def say_name(self):
		print(f"Hi, my name is {self.name}")

Cat = cat()
Cat.say_name()
```

### Синхронность и Асинхронность

**Синхронность** - когда процессы выполняются последовательно. Если первый процесс не выполнен - то следующий не начнётся 
**Асинхронность** - когда процессы выполняются независимости друг от друга. То есть, если задачи не зависят друг от друга они выполняются как два потока. Две и более, параллельные линии. 

**Синхронность**, по умолчанию. 
**Асинхронность**, через объявляется через `async def` и `await`, то есть, настраивается в ручную.

```Python
import asyncio

async def hello():
    await asyncio.sleep(1)
    print("Hello!")

asyncio.run(hello())
```

### Генераторы и Итераторы

**Итератор** - объект, который создан для получения доступа к данным структур - последовательно. То есть, по одному элементу.

__Ручное сознание итератора__.
`__iter__()` - объявления итератора
`__next__()` - следующий элемент в последовательности.

**Пример**
```Python
my_list = [10, 20, 30]
it = iter(my_list)

print(next(it))  # 10
print(next(it))  # 20
print(next(it))  # 30

```

**Генераторы** - объект, последовательность. Она создаётся по ходу, то есть с каждой итерацией будет увеличивать его значение, но не количество элементов - элемент всегда один.   
Старое значение удаляется, как только с ним производится операция.

**Пример**
```Python 
def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()

print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3

```
**Итератор и Генератор** - Первый, работает с готовой структурой, предоставляя последовательный вывод. Второй, создаёт структуру с одним элементом  
### Функция yield()

**yield()** - это ключевое слово объявляющие функцию **генератором**.

### Лямбда-функция map() filter() zip()

**Лямбда-функция** - анонимная одно строчная функция 

```Python
f = lambda x: x * 2 
print(f(2)) # 4
```

Часто используется с **map()**, которая применяет функцию ко всем значениям
```Python
list(map(lambda x: x*2, [1, 2, 3])) # → [2, 4, 6]
```

**filter()** - оставляет только те элементы, где возвращается **True** 
```Python
filter(lambda x: x > 1, [0, 1, 2]) # → [2]
```

**zip()** - Объединяет списки по элементом.
```Python
zip([1,2], ['a','b']) # [(1, 'a'), (2, 'b')]
```

### is и ==

**is** - сравнивает объем в памяти

**==** - сравнивает значение.

### if `__name__ == "__main__":`

**Конструкция**, которая определяет, что код выполняется при запуске файла или как импорте как модуль.

```Python
def main():
	print("Привет")

if __name__ == "main":
	main() # Эта функция не вызовится, если мы импортируем файл с кодом как модуль.
```

`__name__` - Специальная переменная, она есть в любом файле `.py`. При запуске файла на прямую `__name__` становится  `__main__`
